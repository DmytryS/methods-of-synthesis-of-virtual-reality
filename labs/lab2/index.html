<!DOCTYPE html>

<head>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>Hello, AR Cube!</title>
    <!-- include three.js library -->
    <script src='../../libs/js/three.js'></script>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>
    <div class="row">
        <div class="one-half column">
            <h5>Alpha (z): <span id="oalpha">?</span></h5>
        </div>
        <div class="one-half column">
            <h5>Beta (x): <span id="obeta">?</span></h5>
        </div>
        <div class="one-half column">
            <h5>Gamma (y): <span id="ogamma">?</span></h5>
        </div>
    </div>
    <script>
        const oalpha = document.getElementById('oalpha');
        const obeta = document.getElementById('obeta');
        const ogamma = document.getElementById('ogamma');

        const screenOrientation = window.orientation || 0;

        const width = window.innerWidth;
        const height = window.innerHeight;
        const xFunc = (u, v) => a * v * Math.sqrt(1 - v) * Math.cos(u);
        const yFunc = (u, v) => a * v * Math.sqrt(1 - v) * Math.sin(u);
        const zFunc = (u, v) => a * v;
        const a = 0.75, b = 1, c = 1, d = 1;
        const orientation = {
            alpha: 0,
            beta: 0,
            gamma: 0
        };

        let uMin = 0, uMax = 6.286, uRange = uMax - uMin,
            vMin = -1, vMax = 6.286, vRange = vMax - vMin,
            zMin = -10, zMax = 10, zRange = zMax - zMin;

        var renderer, clock, deltaTime, totalTime;

        var arToolkitSource, arToolkitContext;

        var markerRoot1, markerRoot2;

        var mesh1;
        let camera;
        let scene;

        initialize();

        function initialize() {
            scene = new THREE.Scene();

            let ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
            scene.add(ambientLight);

            // camera = new THREE.PerspectiveCamera(
            //     // 45,
            //     // width / height,
            //     // 0.5,
            //     // 20000
            // );
            camera = new THREE.Camera();
            camera.rotation.order = 'YXZ';
            // scene.add(camera);

            camera.lookAt(scene.position);
            // camera.position.set(1,1,1);
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setClearColor(new THREE.Color('lightgrey'), 0)
            renderer.setSize(width, height);
            renderer.domElement.style.position = 'absolute'
            renderer.domElement.style.top = '0px'
            renderer.domElement.style.left = '0px'
            document.body.appendChild(renderer.domElement);

            let geometry1 = createGeometry();
            let material1 = new THREE.MeshNormalMaterial({
                side: THREE.DoubleSide
            });

            const mesh1 = new THREE.Mesh(geometry1, material1);

            mesh1.rotation.x = -90;

            scene.add(mesh1);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function createGeometry() {
            uRange = uMax - uMin;
            vRange = vMax - vMin;
            const meshFunction = function (u0, v0, vector) {
                var u = uRange * u0 + uMin;
                var v = vRange * v0 + vMin;
                var x = xFunc(u, v);
                var y = yFunc(u, v);
                var z = zFunc(u, v);

                if (isNaN(x) || isNaN(y) || isNaN(z))
                    vector.set(0, 0, 0);
                else
                    vector.set(x, y, z);

                return vector;
            };
            const graphGeometry = new THREE.ParametricGeometry(meshFunction, 20, 20);

            graphGeometry.computeBoundingBox();
            zMin = graphGeometry.boundingBox.min.z;
            zMax = graphGeometry.boundingBox.max.z;
            zRange = zMax - zMin;
            let color, point, face, numberOfSides, vertexIndex;

            const faceIndices = ['a', 'b', 'c', 'd'];

            for (var i = 0; i < graphGeometry.vertices.length; i++) {
                point = graphGeometry.vertices[i];
                color = new THREE.Color(0x0000ff);
                color.setHSL(0.7 * (zMax - point.z) / zRange, 1, 0.5);
                graphGeometry.colors[i] = color;
            }

            for (var i = 0; i < graphGeometry.faces.length; i++) {
                face = graphGeometry.faces[i];
                numberOfSides = (face instanceof THREE.Face3) ? 3 : 4;
                for (var j = 0; j < numberOfSides; j++) {
                    vertexIndex = face[faceIndices[j]];
                    face.vertexColors[j] = graphGeometry.colors[vertexIndex];
                }
            }

            return graphGeometry;
        }

        const createQuaternion = function () {

                var finalQuaternion = new THREE.Quaternion();

                var deviceEuler = new THREE.Euler();

                var screenTransform = new THREE.Quaternion();

                var worldTransform = new THREE.Quaternion(- Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around the x-axis

                var minusHalfAngle = 0;

                return function (alpha, beta, gamma, screenOrientation) {

                    deviceEuler.set(beta, alpha, - gamma, 'YXZ');

                    finalQuaternion.setFromEuler(deviceEuler);

                    minusHalfAngle = - screenOrientation / 2;

                    screenTransform.set(0, Math.sin(minusHalfAngle), 0, Math.cos(minusHalfAngle));

                    finalQuaternion.multiply(screenTransform);

                    finalQuaternion.multiply(worldTransform);

                    return finalQuaternion;

                }

            }();

        const createRotationMatrix = function () {

                var finalMatrix = new THREE.Matrix4();

                var deviceEuler = new THREE.Euler();
                var screenEuler = new THREE.Euler();
                var worldEuler = new THREE.Euler(- Math.PI / 2, 0, 0, 'YXZ'); // - PI/2 around the x-axis

                var screenTransform = new THREE.Matrix4();

                var worldTransform = new THREE.Matrix4();
                worldTransform.makeRotationFromEuler(worldEuler);

                return function (alpha, beta, gamma, screenOrientation) {

                    deviceEuler.set(beta, alpha, - gamma, 'YXZ');

                    finalMatrix.identity();

                    finalMatrix.makeRotationFromEuler(deviceEuler);

                    screenEuler.set(0, - screenOrientation, 0, 'YXZ');

                    screenTransform.identity();

                    screenTransform.makeRotationFromEuler(screenEuler);

                    finalMatrix.multiply(screenTransform);

                    finalMatrix.multiply(worldTransform);

                    return finalMatrix;

                }

            }();

        function onOrientationEvent(e) {
            var alpha, beta, gamma, orient;
            var deviceMatrix;

            alpha = THREE.Math.degToRad(e.alpha || 0); // Z
            beta = THREE.Math.degToRad(e.beta || 0); // X'
            gamma = THREE.Math.degToRad(e.gamma || 0); // Y''
            orient = THREE.Math.degToRad(screenOrientation || 0); // O

            oalpha.textContent = alpha;
            obeta.textContent = beta;
            ogamma.textContent = gamma;

            // only process non-zero 3-axis data
            if (alpha !== 0 && beta !== 0 && gamma !== 0) {
                deviceMatrix = createRotationMatrix(alpha, beta, gamma, orient);

                deviceQuat.setFromRotationMatrix(deviceMatrix);
                // camera.quaternion.copy(deviceQuat);
                camera.rotation.getRotationFromMatrix(deviceMatrix);
            }

        }

        function onScreenOrientationChange() {
            screenOrientation = window.orientation || 0;
        };

        window.addEventListener('deviceorientation', onOrientationEvent, true);
        window.addEventListener('orientationchange', onScreenOrientationChange, true);
    </script>
</body>

</html>
